# 키란?
기본키와 외래키를 알아보기 전에 DB에서 키(KEY)란 무엇인지?
- DB에서 조건을 만족하는 레코드를 찾거나 순서대로 정렬할 때 레코드를 서로 구분할 수 있는 기준이 되는 속성

종류
- Primary Key (기본키, PK)
- Foreign Key (외래키, FK)
- Super Key (수퍼키)
  - 유일성만 만족하면 Super Key
- Candidate Key (후보키)
  - Super Key 중 최소성을 만족하는 Key
- Alternate Key (대체키)
  - 기본키 제외한 나머지 후보키
- Composite Key (복합키)
  - 두 개 이상의 컬럼을 묶어 하나의 기본키로 지정

기본 개념
- 유일성
  - 중복 X
- 최소성
  - 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 

# 외래키
Foreign Key (외래키, FK)
- 테이블간의 관계를 나타낼 때 사용
- 다른 테이블의 기본키를 참조해 외래키로 사용
  - 즉, 한 테이블의 외래키는 연결되어있는 다른 테이블의 기본키
- 왜 사용하는가?
  - 데이터 무결성을 위해
    - 한 쪽의 값이 변경되었는데 다른 쪽은 변경되지 않는다면 문제가 생길 것.

# 기본키
Primary Key (기본키, PK)
- 후보키들 중 메인으로 선정되는 키 -> 후보키 성질을 가짐
- 유일성과 최소성을 가지며, 레코드 식별에 기준이 되는 반드시 필요한 키
- 추가적 조건
  - 값의 변동이 잦은 후보키는 부적절
  - NULL 값을 가질 수 있는 속성이 포함된 후보키는 부적절
  - 후보키 중 단순한 키를 기본키로 설정
  - 하나의 테이블에는 반드시 하나의 기본키만 존재

# ER 다이어그램
ERD
- Entity-Relation Diagram, 개체 관계도
- 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해 사용

# 복합 키
Composite Key
- 두 개 이상의 컬럼을 묶어 하나의 기본키로 지정
- 기본키는 테이블당 하나 -> 컬럼도 하나라는 뜻은 아님
  - 두 개의 컬럼이 묶여 하나의 기본키로 사용 가능
  - 즉, (1, 2) 와 (1, 1) 은 엄연히 다른 것
- 복합키 또한 유일성과 최소성을 만족해야함

# 연관관계
일대일 (1 To 1)
- 하나의 레코드가 상대 테이블의 레코드 단 하나와 관계를 갖는 것
![image](https://github.com/user-attachments/assets/1617392e-6501-4286-a6d3-e3c464bf3e97)


일대다 (1 To N)
- 한 쪽 테이블의 테코드가 관계를 맺은 테이블의 여러 레코드와 연결되는 것
![image](https://github.com/user-attachments/assets/1b2b2462-dd90-4c8c-a660-b9e0a8d70357)


다대다 (N TO M)
- 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계를 갖는 것
![image](https://github.com/user-attachments/assets/d322c945-0bcf-4c6d-9084-33a305475af5)


# 정규화
목표
- 테이블 간 중복된 데이터를 허용하지 않는 것
- 무결성 유지, DB 저장 용량 감소
- 여러 단계로 나누어져 있음

제 1 정규화
- 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블 분해
- 예시
  
![image](https://github.com/user-attachments/assets/29240433-54bd-4272-8041-36fed41bd67a)

- 위 사진을 보면 추신수와 박세리는 2개의 취미를 갖고 있기 때문에 제 1 정규화를 만족하지 못한다.

![image](https://github.com/user-attachments/assets/6c2f474d-2cba-473d-aa9f-5295a9b8026d)

- 제 1 정규화를 진행하면 위 사진처럼 된다

제 2 정규화
- 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것
- 완전 함수 종속 이란?
  - 기본키의 부분집합이 결정자가 되어선 안된다는 것
- 예시

![image](https://github.com/user-attachments/assets/cdd55508-3c64-4402-86d7-7d48022d380c)

- 위 사진을 보면 기본키는 (학생번호, 강좌이름) 으로 복합키
- 복합 기본키는 성적을 결정
- 근데 여기서 강의실은 기본키의 부분집합인 강좌이름에 의해 결정이 될 수 있다 -> 2 정규형 불만족

![image](https://github.com/user-attachments/assets/805f45fb-e4a6-44d7-9aa0-19d925434f57)

- 2 정규화를 통해 위 사진처럼 강의실을 별도의 테이블로 분해하여 만족시킬 수 있다.

제 3 정규화
- 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것
- 이행적 종속이란?
  - A -> B, B -> C 가 성립될 때 A -> C 가 성립되는 것
- 예시

![image](https://github.com/user-attachments/assets/4f2850e4-f2dc-4711-a235-5739b32b9f27)

- 위 사진을 보면 학생 번호가 강좌 이름을 결정, 강좌 이름이 수강료를 결정하고 있다

![image](https://github.com/user-attachments/assets/6adda164-cc6d-4fb8-8716-b3fa95887382)

- 3 정규화를 통해 위 사진처럼 테이블을 분해하여 제 3 정규형을 만족할 수 있다

BCNF 정규화
- 제 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
- 예시

![image](https://github.com/user-attachments/assets/836d110c-377f-4249-915a-7a67a83fddeb)

- 위 사진을 보면 기본키는 (학생번호, 특강이름) 이다
- 기본키는 교수를 결정하고 있고 교수 또한 특강 이름을 결정하고 있다.
- 여기서 문제는 교수가 특강 이름을 결정하는 결정자이지만, 후보키는 아니라는 부분이다

![image](https://github.com/user-attachments/assets/52b8c653-996b-49ce-97fe-f26783d41516)

- 위 사진처럼 특강신청 테이블과 특강교수 테이블로 분해하여 BCNF 전규형을 만족시킬 수 있다.

P.S. 항상 생각하지만 정규화는 참 글로 쓰면 어렵게 느껴지는데 평소에 자연스럽게 하던 것 같다.

# 반 정규화
- 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발 운영 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
- 즉, 성능향상을 위해 정규화된 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정
- 반정규화 적용하면 데이터 무결성 깨질 수 있는 위험이 있다

왜하는가?
- 데이터 조회할 때 조인으로 인한 성능저하 예상될 떄

테이블 반정규화
- 테이블 병합
- 테이블 분할
- 테이블 추가

칼럼 반정규화
- 중복칼럼 추가
- 파생칼럼 추가
- 이력테이블 칼럼추가
- PK에 의한 칼럼 추가
- 응용시스템 오작동을 위한 칼럼 추가

관계 반정규화
- 중복관계 추가
