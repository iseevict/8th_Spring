**지연로딩과 즉시로딩의 차이**

지연로딩

- DB가 아닌 프록시에서 데이터를 가져옴
- 엔티티에 접근할 때 쿼리문 날아감 

즉시로딩

- DB에서 데이터를 가져옴
- 하나의 쿼리로 연관된 데이터 모두 조회하는 쿼리 날림

**Fetch Join**
- JPQL에서 성능 최적화를 위해 제공하는 조인의 종류
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회할 수 있는 기능
- `JOIN FETCH`  명령어로 사용 가능
- 처음 조회부터 조인시켜 데이터를 가져올 수 있게 하기 위해 등장

일반 Join과의 차이점

- 연관된 엔티티들도 모두 영속화된다

특징

- Fetch.Type 같이 엔티티에 직접 설정하는 로딩 전략은 애플리케이션 전체에 영향을 미침
    - 글로벌 로딩 전략 이라고 함
- Fetch Join 은 글로벌 로딩 전략보다 우선시
    - Fetch.Type 을 Lazy 로 설정해도 Fetch Join 사용하면 데이터가 즉시 조회됨
- 객체 그래프를 유지할 때 사용하면 효과적

한계

- Fetch Join 대상에는 별칭을 줄 수 없음
    - SELECT, WHERE, 서브쿼리 에 Fetch Join 대상을 사용할 수 없음
    - 이러한 제약을 둔 이유
        - 데이터 무결성을 위해
        - JPA 표준에선 지원하지 않지만 하이버네이트 포함 몇몇 구현체들은 별칭 지원
- 데이터가 증폭되는 문제로 둘 이상의 컬렉션을 Fetch 할 순 없음
    - 컬렉션 * 컬렉션 이므로 가능한 구현체에서도 주의해서 사용해야 함
- 컬렉션을 Fetch Join 하면 페이징 사용이 불가함
    - 일대일, 다대일 같이 단일값 연관 필드는 페이징 가능
    - 하이버네이트에서 사용하게 되면 경고 로그를 남기고 모든 데이터를 불러와 메모리에서 페이징 진행
        - 매우 위험한 작업

**@EntityGraph**
- 연관관계가 있는 엔티티를 조회할 때 지연로딩을 설정되어 있는 경우 해당 어노테이션을 통해 Fetch Join 을 사용하여 여러 번의 쿼리를 한 번에 해결할 수 있다
- 즉, Fetch Join 을 어노테이션을 통해 사용할 수 있도록 한 기능
- Repository 필요한 부분에 붙여서 사용 가능

[image.png](attachment:e467a808-ac5d-4e3e-aed8-33fab1949a0d:image.png)

타입

- 2가지가 존재
    - FETCH, LOAD
- FETCH
    - default 타입
    - 어노테이션에 명시한 attribute 를 EAGER 로 패치, 나머지는 LAZY
- LOAD
    - 어노테이션에 명시한 attribute 를 EAGER 로 패치, 나머지는 Entity에 명시한 Fetch Type을 따름

**JPQL**

SQL

- DB에 있는 테이블을 조회하는 쿼리

JPQL

- 엔티티 객체를 조회하는 객체지향 쿼리
- SQL이랑 문법/기능 유사함
- SQL을 추상화하였기에 특정 데이터베이스에 의존하지 않음
    - DB 방언만 변경하면 JPQL을 수정하지 않고 자연스럽게 DB 변경 가능
- 엔티티 직접 조회, 묵시적 조인, 다형성 지원 등의 기능 제공
    - SQL보다 간결함

**QueryDSL**
    - 타입 안전성을 보장하는 자바 기반의 쿼리 빌더 라이브러리
    - 코드 기반의 쿼리 빌더 제공 → 컴파일 시점에 쿼리의 오류 잡을 수 있음
    - 동적 쿼리 작성 편리
    - 메서드 체이닝을 통한 복잡한 쿼리 작성에 유리
    - 가독성 좋음

N+1 문제 해결 방법

N+1 문제란?

- 부모 엔티티 1건 조회 + 지연 로딩 → 연관된 자식 N건을 순차적으로 조회하면서 총 N + 1 개의 쿼리문이 발생하는 현상

해결법

- Fetch Join
  - JPQL  의 FETCH JOIN 을 통해 부모와 자식을 한 번에 가져옴
  - 단순하고 고성능 / 다수의 컬렉션 조인/페이징 과 함께 사용하면 카테시안 곱 발생하므로 위험
- @EntityGraph
    - 필요한 시점만 EAGER 로딩
    - 메서드 단위로 선택적 적용가능 / 복잡한 그래프 지정 시 가동성이 저하됨
- DTO
    - 조회 전용 DTO로 필요한 필드만 한 큐에 저장
    - 전송량, 메모리 절감 / 코드 추가 필요
- Batch Fetching
    - 하이버네이트가 Lazy를 모아서 IN 절로 일괄 조회
    - 코드 수정 없고 여러 연관관계 동시 적용 가능 / IN 리스트가 너무 커지면 또 다른 부하가 생김
- 등 여러 방법이 있다.

개인적으로 직접 @Query 를 통해 FETCH JOIN 을 하는게 가장 가독성 좋다고 생각