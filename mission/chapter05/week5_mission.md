### 일반 미션

- 기준 ERD
![image](https://github.com/user-attachments/assets/55282218-46a8-4b4a-a602-67877db104c9)

- 미션 인증
![image](https://github.com/user-attachments/assets/6b5a0b4b-f4ea-4014-9149-c12ca7a3709b)

- 미션 레포 주소
  -  https://github.com/iseevict/8th_spring_prac/tree/mission5

## 시니어 미션

### 1. @OneToMany 컬렉션을 조회할 때 List\<MemberPrefer>를 Set\<MemberPrefer>로 변경 후 차이점 분석
- **`@OneToMany` 컬렉션을 조회할 때 `List<MemberPrefer>`를 `Set<MemberPrefer>`로 변경 후 차이점 분석**
    - 모두 단방향으로 구현하여 @OneToMany 가 없어 변경은 못하였습니다.
    - 차이점
        - List는 중복을 허용하지만 Set 은 중복을 허용하지 않음
        - List는 순서를 보장, Set은 순서를 보장하지 않음
    - 성능 차이
        - List는 순차적으로 요소에 접근하는 데 효율적
            - 중복 검사에 O(n) 만큼 시간 복잡도를 가짐
        - Set은 중복 검사가 내장되어 있음
            - 중복 검사에 O(1) 만큼 시간 복잡도를 가짐
    - 메모리 차이
        - List는 순차적으로 데이터를 저장하므로 배열 기반 → 메모리 오버헤드가 상대적으로 적음
            - but, 중복 데이터로 오히려 더 많은 메모리를 사용할 수 있음
        - Set은 중복을 허용하지 않지만, 내부적으로 해시 테이블이나 트리 구조와 같은 자료 구조를 사용 → 메모리 오버헤드가 더 클 수 있음
    - 결론
        - List는 중복 허용, 순서 보장 이 필요한 경우 적합
        - Set은 중복을 허용하지 않으며 순서가 중요하지 않은 경우, 빠른 중복 검사 및 성능 최적화가 필요한 경우 적합

### 2. 데이터 정합성을 고려하여 orphanRemoval = true 가 필요한 곳 확인 후 적용
- 데이터 정합성?
    - 데이터가 정확하고, 오류 없이 일관성을 유지하는 것
- orphanRemoval 란?
    - JPA 에서 부모 엔티티에서 자식 엔티티가 고아 상태 (orphaned) 로 남아 있을 때 이를 자동으로 삭제하도록 설정하는 옵션
- 필요한 곳 확인 후 적용
    - 일대다 단방향/양방향 의 경우 사용하는 것으로 알고 있습니다.
    - 제가 구현한 코드는 현재 다대일 단방향만 존재하기에 사용할 곳이 없습니다.

### 3. 하나의 트랜잭션에서 여러 엔티티를 처리하는 비즈니스 로직 구현

#### 3-1. Member 가 탈퇴할 경우 관련된 모든 데이터를 삭제하는 API 구현

#### 3-2. @Transactional 을 적용하고, @Modifying 을 활용하여 Batch Delete 쿼리 최적화

### 4. 동시성 문제가 발생할 수 있는 시나리오를 고민하고 해결책 적용

#### 4-1. 같은 회원이 동시에 같은 Store 를 찜하려고 할 때 중복이 발생하지 않도록 @Lock 사용

#### 4-2. 다양한 락킹 전략에 대해 공부해보고, 이를 정리하기